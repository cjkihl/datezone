---
title: Best Practices
description: Essential best practices for building robust date and time handling in your applications with datezone
---



Building reliable applications that handle dates and times correctly requires following proven best practices. These guidelines will help you avoid common pitfalls and build maintainable, bug-free date logic.

## Core Principles

### 1. Always Specify Timezones Explicitly

Never rely on the system timeZone for date operations. This creates unpredictable behavior that varies between environments.

<CodeExample tabs={[{ name: "Example 1", file: "guides/how-dst-works/this-assumption-is-dangerous.ts" }]} />

<Callout type="info">
**User experience tip**: Default to the user's detected timeZone, but always allow them to override it. This is how most calendar applications like Outlook handle timeZone selection.
</Callout>

### 2. Store Timestamps, Display with Calendar Dates

Use timestamps for storage and use to Timezone sensitive Calendar only for display and calculations.

<CodeExample tabs={[{ name: "Example 2", file: "guides/best-practices/user-settings-probably-set-in-a-database-or-local-storage.ts" }]} />

### 3. Never Use simple Arithmetic for Calendar Operations

Don't add milliseconds directly to timestamps for date operations. DST transitions make this unreliable.

Read more about this in [how DST Works](/docs/guides/how-dst-works)

<CodeExample tabs={[{ name: "Example 3", file: "guides/how-dst-works/this-breaks-during-dst-transitions.ts" }]} />

<Callout type="warning">
**DST gotcha**: During DST transitions, some days are 23 or 25 hours long. Simple arithmetic will give you the wrong calendar date.
</Callout>

## Database and API Design

### 1. Store Timestamps in Your Database

Use timestamp columns in your database schema, not datetime strings.

```sql
-- ✅ PostgreSQL example
CREATE TABLE events (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  created_at BIGINT NOT NULL,  
  start_time BIGINT NOT NULL,  
  end_time BIGINT NOT NULL
);
```

<CodeExample tabs={[{ name: "Example 4", file: "guides/best-practices/typescript-interface.type" }]} />

### 2. Include Timezone Information in APIs

When an API needs timeZone context, include it explicitly in your requests and responses.

<CodeExample tabs={[{ name: "Example 5", file: "guides/best-practices/api-request-with-timeZone-context.type" }]} />

### 3. Validate Timezone Parameters

Always validate timeZone strings to prevent runtime errors.

<CodeExample tabs={[{ name: "Example 6", file: "guides/best-practices/timeZone-validation-helper.type" }]} />

## Performance Optimization

### 1. Minimize DST Calculations

Datezone offers base functions that work with calendar to avoid repeated DST calculations.

<CodeExample tabs={[{ name: "Example 7", file: "guides/best-practices/repeated-dst-calculations.type" }]} />

### 2. Cache Timezone Operations

For applications with many timeZone operations, consider caching formatted results.

<CodeExample tabs={[{ name: "Example 8", file: "guides/best-practices/simple-timeZone-formatter-cache.type" }]} />

## Testing Best Practices

### 1. Test Around DST Transitions

Always include DST transition dates in your test suite.

<CodeExample tabs={[{ name: "Example 9", file: "guides/best-practices/test-critical-dst-dates.type" }]} />

### 2. Use Fixed Timestamps in Tests

Avoid `Date.now()` in tests. Use fixed timestamps for predictable testing.

<CodeExample tabs={[{ name: "Example 10", file: "guides/best-practices/fixed-timestamp-for-consistent-tests.type" }]} />

### 3. Test Multiple Timezones

Test your logic across different timeZone types.

<CodeExample tabs={[{ name: "Example 11", file: "guides/best-practices/example-11.prisma" }]} />

## User Interface Guidelines

### 1. Show Timezone Context

Always display timeZone information in your UI when showing times.

<CodeExample tabs={[{ name: "Example 12", file: "guides/best-practices/example-12.type" }]} />

### 2. Handle Timezone Selection

Provide timeZone selection with smart defaults.

<CodeExample tabs={[{ name: "Example 13", file: "guides/best-practices/example-13.type" }]} />

## Error Handling

### 1. Graceful Timezone Fallbacks

Handle invalid timeZones gracefully.

<CodeExample tabs={[{ name: "Example 14", file: "guides/best-practices/safe-timeZone-operations-with-fallbacks.type" }]} />

### 2. Validate Date Inputs

Always validate date inputs from users.

<CodeExample tabs={[{ name: "Example 15", file: "guides/best-practices/input-validation.type" }]} />

## Migration Strategies

### 1. Gradual Migration from Date Objects

Migrate your codebase gradually by introducing wrapper functions.

<CodeExample tabs={[{ name: "Example 16", file: "guides/best-practices/migration-wrapper.type" }]} />

### 2. Database Migration

Migrate database columns gradually with dual storage.

```sql
-- ✅ Add new timestamp column alongside old datetime
ALTER TABLE events 
ADD COLUMN start_time_ts BIGINT;

-- Populate new column
UPDATE events 
SET start_time_ts = EXTRACT(EPOCH FROM start_time) * 1000;

-- Eventually drop old column after migration
-- ALTER TABLE events DROP COLUMN start_time;
```

## Summary

Following these best practices will help you build robust, maintainable applications with reliable date and time handling:

1. **Always specify timeZones explicitly**
2. **Store timestamps, display with timeZone context**
3. **Never use arithmetic for calendar operations**
4. **Test around DST transitions**
5. **Validate all timeZone inputs**
6. **Provide clear timeZone context in UIs**

<Callout type="success">
**Golden rule**: When in doubt, be explicit about timeZones. The extra verbosity will save you from hard-to-debug issues in production.
</Callout>

These practices, combined with datezone's timeZone-aware functions, will eliminate the vast majority of date-related bugs in your applications.

