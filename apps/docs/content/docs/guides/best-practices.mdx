---
title: Best Practices
description: Essential best practices for building robust date and time handling in your applications with datezone
---



Building reliable applications that handle dates and times correctly requires following proven best practices. These guidelines will help you avoid common pitfalls and build maintainable, bug-free date logic.

## Core Principles

### 1. Always Specify Timezones Explicitly

Never rely on the system timezone for date operations. This creates unpredictable behavior that varies between environments.

<CodeExample tabs={[{ name: "Example 1", file: "guides/best-practices/example-1.ts" }]} />

<Callout type="info">
**User experience tip**: Default to the user's detected timezone, but always allow them to override it. This is how professional applications like Outlook handle timezone selection.
</Callout>

### 2. Store Timestamps, Display with Timezones

Use timestamps for storage and calculations, but convert to localized formats only for display.

<CodeExample tabs={[{ name: "Example 2", file: "guides/best-practices/example-2.ts" }]} />

### 3. Never Use Date Arithmetic for Calendar Operations

Don't add milliseconds directly to timestamps for date operations. DST transitions make this unreliable.

<CodeExample tabs={[{ name: "Example 3", file: "guides/best-practices/example-3.ts" }]} />

<Callout type="warning">
**DST gotcha**: During DST transitions, some days are 23 or 25 hours long. Simple arithmetic will give you the wrong calendar date.
</Callout>

## Database and API Design

### 1. Store Timestamps in Your Database

Use timestamp columns in your database schema, not datetime strings.

```sql
-- ✅ PostgreSQL example
CREATE TABLE events (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  created_at BIGINT NOT NULL,  -- Timestamp
  start_time BIGINT NOT NULL,  -- Timestamp
  end_time BIGINT NOT NULL     -- Timestamp
);
```

<CodeExample tabs={[{ name: "Example 4", file: "guides/best-practices/example-4.ts" }]} />

### 2. Include Timezone Information in APIs

When an API needs timezone context, include it explicitly in your requests and responses.

<CodeExample tabs={[{ name: "Example 5", file: "guides/best-practices/example-5.ts" }]} />

### 3. Validate Timezone Parameters

Always validate timezone strings to prevent runtime errors.

<CodeExample tabs={[{ name: "Example 6", file: "guides/best-practices/example-6.ts" }]} />

## Performance Optimization

### 1. Minimize DST Calculations

Datezone offers base functions that work with wall time to avoid repeated DST calculations.

<CodeExample tabs={[{ name: "Example 7", file: "guides/best-practices/example-7.ts" }]} />

### 2. Cache Timezone Operations

For applications with many timezone operations, consider caching formatted results.

<CodeExample tabs={[{ name: "Example 8", file: "guides/best-practices/example-8.ts" }]} />

## Testing Best Practices

### 1. Test Around DST Transitions

Always include DST transition dates in your test suite.

<CodeExample tabs={[{ name: "Example 9", file: "guides/best-practices/example-9.ts" }]} />

### 2. Use Fixed Timestamps in Tests

Avoid `Date.now()` in tests. Use fixed timestamps for predictable testing.

<CodeExample tabs={[{ name: "Example 10", file: "guides/best-practices/example-10.ts" }]} />

### 3. Test Multiple Timezones

Test your logic across different timezone types.

<CodeExample tabs={[{ name: "Example 11", file: "guides/best-practices/example-11.prisma" }]} />

## User Interface Guidelines

### 1. Show Timezone Context

Always display timezone information in your UI when showing times.

<CodeExample tabs={[{ name: "Example 12", file: "guides/best-practices/example-12.tsx" }]} />

### 2. Handle Timezone Selection

Provide timezone selection with smart defaults.

<CodeExample tabs={[{ name: "Example 13", file: "guides/best-practices/example-13.tsx" }]} />

## Error Handling

### 1. Graceful Timezone Fallbacks

Handle invalid timezones gracefully.

<CodeExample tabs={[{ name: "Example 14", file: "guides/best-practices/example-14.ts" }]} />

### 2. Validate Date Inputs

Always validate date inputs from users.

<CodeExample tabs={[{ name: "Example 15", file: "guides/best-practices/example-15.ts" }]} />

## Migration Strategies

### 1. Gradual Migration from Date Objects

Migrate your codebase gradually by introducing wrapper functions.

<CodeExample tabs={[{ name: "Example 16", file: "guides/best-practices/example-16.ts" }]} />

### 2. Database Migration

Migrate database columns gradually with dual storage.

```sql
-- ✅ Add new timestamp column alongside old datetime
ALTER TABLE events 
ADD COLUMN start_time_ts BIGINT;

-- Populate new column
UPDATE events 
SET start_time_ts = EXTRACT(EPOCH FROM start_time) * 1000;

-- Eventually drop old column after migration
-- ALTER TABLE events DROP COLUMN start_time;
```

## Summary

Following these best practices will help you build robust, maintainable applications with reliable date and time handling:

1. **Always specify timezones explicitly**
2. **Store timestamps, display with timezone context**
3. **Never use arithmetic for calendar operations**
4. **Test around DST transitions**
5. **Validate all timezone inputs**
6. **Provide clear timezone context in UIs**

<Callout type="success">
**Golden rule**: When in doubt, be explicit about timezones. The extra verbosity will save you from hard-to-debug issues in production.
</Callout>

These practices, combined with datezone's timezone-aware functions, will eliminate the vast majority of date-related bugs in your applications.

