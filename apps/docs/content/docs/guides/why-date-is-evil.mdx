---
title: Why JavaScript Date is is Hard
description: Understanding the fundamental problems with JavaScript's Date object and why you should avoid it
---



JavaScript's `Date` object is one of the most problematic APIs in the language. While it seems convenient at first, it's the source of countless bugs and unpredictable behavior in applications. Here's why you should avoid it and what to use instead.

## The Core Problems

### 1. No Timezone Support

The `Date` object doesn't properly support timeZones. It only knows about the local system timeZone and UTC, making it difficult to work with dates in specific timeZones reliably.

<CodeExample tabs={[{ name: "Example 1", file: "guides/why-date-is-evil/const-date-new-date2024-01-01.type" }]} />

<Callout type="warning">
**Machine-dependent behavior**: The same code produces different results depending on where it's executed. This makes your application unpredictable and hard to test.
</Callout>

### 2. Confusing constructor

The `Date` object's constructor string parser have strange implicit behavours and is prone to a lot a hard to track errors.

<CodeExample tabs={[{ name: "Example 2", file: "guides/why-date-is-evil/these-behave-differently.type" }]} />

### 3. Mutable State = Bugs

`Date` objects are mutable, which leads to unexpected side effects and hard-to-track bugs.

<CodeExample tabs={[{ name: "Example 3", file: "guides/why-date-is-evil/const-date-new-date2024-01-01-creates-a-new-date-2024-01-01-0000-utc.type" }]} />

<Callout type="danger">
**Mutation bugs**: Methods like `setHours()`, `setDate()`, etc. modify the original object instead of returning a new one. This violates the principle of immutability and can cause subtle bugs.
</Callout>

### 4. Unpredictable Results

The same code returns different results depending on the system timeZone, making unit testing unreliable.

<CodeExample tabs={[{ name: "Example 4", file: "guides/why-date-is-evil/this-represents-midnight-utc-on-jan-1-2024.type" }]} />

### 5. Not Serializable

`Date` objects don't serialize well. When you send them over HTTP or store them in JSON, you lose the Date() object.

<CodeExample tabs={[{ name: "Example 5", file: "guides/why-date-is-evil/parseddate-is-now-a-string-not-a-date-object.type" }]} />

<Callout type="info">
**Serialization problems**: Libraries like `superjson` exist to work around this, but they add complexity and overhead to your application.
</Callout>

## The Alternative: Timestamps

JavaScript has a much better built-in native type for handling dates: `number` (timestamps)!

### Why Timestamps Are Better

- **Immutable**: Numbers can't be mutated
- **Serializable**: Numbers work perfectly with JSON
- **Predictable**: Always represent the same moment in time no matter which timeZone you are in. 
- **Efficient**: No memory overhead on the JavaScript heap
- **Testable**: Same input always produces the same output

<CodeExample tabs={[{ name: "Example 6", file: "guides/why-date-is-evil/clean-predictable-testable.type" }]} />

### Working with Timestamps

Instead of using `Date` methods, use datezone functions that work with timestamps:

<CodeExample tabs={[{ name: "Example 7", file: "guides/why-date-is-evil/import-adddays-format-from-datezone.type" }]} />

## Migration Strategy

### Step 1: Stop Creating Date Objects

<CodeExample tabs={[{ name: "Example 8", file: "guides/why-date-is-evil/dont-do-this.type" }]} />

### Step 2: Replace Date Methods with Timezone-Aware Functions

<CodeExample tabs={[{ name: "Migrate to Datezone", file: "guides/migrate-simple.type" }]} />

<Callout type="info">
**Understanding Timezone Parameters**: Most datezone functions require an explicit `timeZone` parameter to ensure predictable behavior across different environments. Functions like `addHours` work with raw timestamps and don't need timeZone context since they add fixed durations. However, operations that depend on calendar concepts (days, months, years) need timeZone information to handle DST transitions correctly.
</Callout>


## Summary

The JavaScript `Date` object is fundamentally flawed and should be avoided in production applications. By using timestamps and timeZone-aware functions like those provided by datezone, you can build more reliable, testable, and maintainable applications.

<Callout type="success">
**Key takeaway**: Store timestamps, display with explicit timeZones. This approach eliminates the vast majority of date-related bugs in JavaScript applications.
</Callout>

Next, learn about [why timestamps are the better choice](/docs/guides/why-use-timestamps) for your applications.